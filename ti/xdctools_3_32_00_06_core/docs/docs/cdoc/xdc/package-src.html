<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>package xdc</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> *  Copyright (c) 2008 Texas Instruments and others.
</span>     3    <span class="comment"> *  All rights reserved. This program and the accompanying materials
</span>     4    <span class="comment"> *  are made available under the terms of the Eclipse Public License v1.0
</span>     5    <span class="comment"> *  which accompanies this distribution, and is available at
</span>     6    <span class="comment"> *  http://www.eclipse.org/legal/epl-v10.html
</span>     7    <span class="comment"> * 
</span>     8    <span class="comment"> *  Contributors:
</span>     9    <span class="comment"> *      Texas Instruments - initial implementation
</span>    10    <span class="comment"> * 
</span>    11    <span class="comment"> * */</span>
    12    <span class="xdoc">/*!
</span>    13    <span class="xdoc"> *  ======== xdc ========
</span>    14    <span class="xdoc"> *  Core interfaces and modules necessary for the XDC runtime.
</span>    15    <span class="xdoc"> *
</span>    16    <span class="xdoc"> *  In addition to the interfaces specified below, this package also supplies
</span>    17    <span class="xdoc"> *  a C/C++ header, `std.h` that facilitates the creation of portable sources.
</span>    18    <span class="xdoc"> *  This header defines a set of "base" types that enable the creation
</span>    19    <span class="xdoc"> *  of C-code that is portable between any two targets.  C source code that
</span>    20    <span class="xdoc"> *  relies exclusively on these types is portable to all targets and
</span>    21    <span class="xdoc"> *  platforms.  Where appropriate, the types defined below are related to the
</span>    22    <span class="xdoc"> *  types defined in the library headers prescribed by the C99 standard
</span>    23    <span class="xdoc"> *  (ISO/IEC 9899:1999).
</span>    24    <span class="xdoc"> *
</span>    25    <span class="xdoc"> *  Why not simply use the C99 types?  Having a
</span>    26    <span class="xdoc"> *  unique set of names provides a layer of insulation between a portable code
</span>    27    <span class="xdoc"> *  base and a particular compiler; e.g., even if a compiler does not support
</span>    28    <span class="xdoc"> *  the C99 types or defines them inappropriately for a particular device, it
</span>    29    <span class="xdoc"> *  is possible to use the compiler without changing the code base.  Thus, the
</span>    30    <span class="xdoc"> *  developer is not forced to choose the lesser of two evils: waiting for a
</span>    31    <span class="xdoc"> *  change to the compiler or forking the code base for a particular compiler
</span>    32    <span class="xdoc"> *  device combination.
</span>    33    <span class="xdoc"> *
</span>    34    <span class="xdoc"> *  There are several situations where a small separate set of portable types
</span>    35    <span class="xdoc"> *  can help the maintainability of a code base.
</span>    36    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    37    <span class="xdoc"> *      - not all of the types described in the C99 standard are required to 
</span>    38    <span class="xdoc"> *        be defined by conformant implementations nor is it possible for all
</span>    39    <span class="xdoc"> *        devices to implement some of the types specified (e.g., `int8_t` is
</span>    40    <span class="xdoc"> *        not implemented on C54 devices); so it is difficult to identify
</span>    41    <span class="xdoc"> *        non-portable source code.
</span>    42    <span class="xdoc"> *      - not all compilers provide C99 type support; if XDC supplies the type
</span>    43    <span class="xdoc"> *        definition and the compiler is updated to include C99 types, a
</span>    44    <span class="xdoc"> *        compilation error will occur if the source includes the C99
</span>    45    <span class="xdoc"> *        headers.
</span>    46    <span class="xdoc"> *      - not all compiler and device combinations are conformant; even high
</span>    47    <span class="xdoc"> *        quality compilers may not properly define the types for each device
</span>    48    <span class="xdoc"> *        supported by compiler.
</span>    49    <span class="xdoc"> *
</span>    50    <span class="xdoc"> *  <b>@a(Usage)</b>
</span>    51    <span class="xdoc"> *  <b>@p(code)</b>
</span>    52    <span class="xdoc"> *      #include &lt;xdc/std.h&gt;
</span>    53    <span class="xdoc"> *  <b>@p</b>
</span>    54    <span class="xdoc"> *
</span>    55    <span class="xdoc"> *  To compile sources that include `xdc/std.h`, two symbols must be defined
</span>    56    <span class="xdoc"> *  before including this header:
</span>    57    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>    58    <span class="xdoc"> *      - `xdc_target_types__`
</span>    59    <span class="xdoc"> *          the package qualified path of the target's standard types header;
</span>    60    <span class="xdoc"> *          e.g., `ti/targets/std.h`.  This value is specified in the target's
</span>    61    <span class="xdoc"> *          `stdInclude` config parameter; see
</span>    62    <span class="xdoc"> *          `{<b>@link</b> xdc.bld.ITarget#stdInclude}`
</span>    63    <span class="xdoc"> *
</span>    64    <span class="xdoc"> *      - `xdc_target_name__`
</span>    65    <span class="xdoc"> *          the target's module name without the package prefix; e.g., `C64`
</span>    66    <span class="xdoc"> *          rather than `ti.targets.C64`.
</span>    67    <span class="xdoc"> *  <b>@p</b>
</span>    68    <span class="xdoc"> *  For example, to compile sources for the `ti.targets.C64` target using TI's
</span>    69    <span class="xdoc"> *  `cl6x` compiler, the following command line is sufficient:
</span>    70    <span class="xdoc"> *  <b>@p(code)</b>
</span>    71    <span class="xdoc"> *      cl6x -Dxdc_target_types__=ti/targets/std.h -Dxdc_target_name__=C64
</span>    72    <span class="xdoc"> *  <b>@p</b>
</span>    73    <span class="xdoc"> *
</span>    74    <span class="xdoc"> *  Each of the type names below has an equivalent "long name"; i.e., a name
</span>    75    <span class="xdoc"> *  that has an "`xdc_`" prefix.  For example, the type `Bool` can also be
</span>    76    <span class="xdoc"> *  written as "`xdc_Bool`".  Long names exist to avoid conflicts with
</span>    77    <span class="xdoc"> *  names defined or used by existing code bases.
</span>    78    <span class="xdoc"> *
</span>    79    <span class="xdoc"> *  In the event that one of the short type names below conflicts with another
</span>    80    <span class="xdoc"> *  type name (that can not be changed), it is possble to disable the short
</span>    81    <span class="xdoc"> *  names by defining the symbol `xdc__nolocalnames` before including
</span>    82    <span class="xdoc"> *  `xdc/std.h`.
</span>    83    <span class="xdoc"> *  <b>@p(code)</b>
</span>    84    <span class="xdoc"> *      #define xdc__nolocalnames
</span>    85    <span class="xdoc"> *      #include &lt;xdc/std.h&gt;
</span>    86    <span class="xdoc"> *  <b>@p</b>
</span>    87    <span class="xdoc"> *
</span>    88    <span class="xdoc"> *  There are two other symbols that affect the definitions provided by
</span>    89    <span class="xdoc"> *  `std.h`: `xdc__strict` and `xdc__deprecated_types`.  These symbols, like
</span>    90    <span class="xdoc"> *  `xdc__nolocalnames`, enable you to easily control the definitions provided
</span>    91    <span class="xdoc"> *  `std.h`.  In this case, however, these symbols are used to manage the
</span>    92    <span class="xdoc"> *  deprecation of symbols provided in earlier releases.  For more information
</span>    93    <span class="xdoc"> *  about when to use these symbols, see {<b>@link</b> http://rtsc.eclipse.org/docs-tip/Integrating_RTSC_Modules#Disabling_and_Enabling_Deprecated_Definitions Disabling and Enabling Deprecated Definitions}`.
</span>    94    <span class="xdoc"> *
</span>    95    <span class="xdoc"> *  <b>@a(Standard Types)</b>
</span>    96    <span class="xdoc"> *  This header may be included multiple times and defines the following
</span>    97    <span class="xdoc"> *  target-dependent types:
</span>    98    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>    99    <span class="xdoc"> *      - `Bool`
</span>   100    <span class="xdoc"> *          this type is large enough to hold the values `0` or `1`.  The
</span>   101    <span class="xdoc"> *          constants TRUE and FALSE are of this type; see below.
</span>   102    <span class="xdoc"> *      - `String`
</span>   103    <span class="xdoc"> *          this type is defined to be a `char *` and exists to allow code
</span>   104    <span class="xdoc"> *          to distinguish between pointers to buffers of raw data and
</span>   105    <span class="xdoc"> *          '\0' terminated strings.
</span>   106    <span class="xdoc"> *      - `CString`
</span>   107    <span class="xdoc"> *          this type is defined to be a `const char *` and exists to allow 
</span>   108    <span class="xdoc"> *          code to distinguish between pointers to a modifiable '\0'
</span>   109    <span class="xdoc"> *          terminated sequence of characters (i.e., a `String`) and one that
</span>   110    <span class="xdoc"> *          is not modifiable (e.g., a literal string such as
</span>   111    <span class="xdoc"> *          `"hello world\n"`).
</span>   112    <span class="xdoc"> *      - `Int`n, where n = 8, 16, or 32
</span>   113    <span class="xdoc"> *          signed integer type that is large enough to hold n bits; the
</span>   114    <span class="xdoc"> *          actual target type may by be larger than n.  This type is
</span>   115    <span class="xdoc"> *          equivalent to one of the C99 types `int_least`n`_t` or
</span>   116    <span class="xdoc"> *          `int_fast`n`_t`; see  Section 7.18.
</span>   117    <span class="xdoc"> *      - `UInt`n, where n = 8, 16, or 32
</span>   118    <span class="xdoc"> *          unsigned integer type that is large enough to hold n bits; the
</span>   119    <span class="xdoc"> *          actual target type may by be larger than n.  This type is
</span>   120    <span class="xdoc"> *          equivalent to one of the C99 types `uint_least`n`_t` or
</span>   121    <span class="xdoc"> *          `uint_fast`n`_t`; see ISO/IEC 9899:1999 Section 7.18.
</span>   122    <span class="xdoc"> *      - `Bits`n, where n = 8, 16, or 32
</span>   123    <span class="xdoc"> *          unsigned integer type that is precisely n bits. Not all targets
</span>   124    <span class="xdoc"> *          support all values of n; if the target does not support an exact
</span>   125    <span class="xdoc"> *          size the corresponding type is not defined.  This type is
</span>   126    <span class="xdoc"> *          equivalent to the corresponding C99 type `uint`n`_t`; see ISO/IEC
</span>   127    <span class="xdoc"> *          9899:1999 Section 7.18.
</span>   128    <span class="xdoc"> *      - `Fxn`
</span>   129    <span class="xdoc"> *          this type is a pointer to code; it can hold a pointer to any
</span>   130    <span class="xdoc"> *          function.
</span>   131    <span class="xdoc"> *      - `Ptr`
</span>   132    <span class="xdoc"> *          this type is a pointer to data; it can hold a pointer to any
</span>   133    <span class="xdoc"> *          data structure.
</span>   134    <span class="xdoc"> *      - `IArg`
</span>   135    <span class="xdoc"> *          this integer type is large enough to hold a `Fxn`, `Ptr`, or
</span>   136    <span class="xdoc"> *          `Int`.
</span>   137    <span class="xdoc"> *      - `UArg`
</span>   138    <span class="xdoc"> *          this unsigned integer type is large enough to hold a `Fxn`,
</span>   139    <span class="xdoc"> *          `Ptr`, or `Int`.
</span>   140    <span class="xdoc"> *      - `LLong`
</span>   141    <span class="xdoc"> *          this long integer type is large enough to hold a `Long` and is
</span>   142    <span class="xdoc"> *          defined as a 'long long' type on targets that support this type;
</span>   143    <span class="xdoc"> *          otherwise, it is simply a `Long`.
</span>   144    <span class="xdoc"> *
</span>   145    <span class="xdoc"> *          Note that C99 requires the `long long` type to be at least 64-bits
</span>   146    <span class="xdoc"> *          wide (See ISO/IEC 9899:1999 Section 5.2.4.2.1).  But some
</span>   147    <span class="xdoc"> *          compilers do not support 64-bit integral types and some don't
</span>   148    <span class="xdoc"> *          support the `long long` even though they do support 64-bit
</span>   149    <span class="xdoc"> *          integral types.  Since these variations limit the portability of
</span>   150    <span class="xdoc"> *          valid C sources, the LLong type is always defined, is always at
</span>   151    <span class="xdoc"> *          least as wide as the `Long` type, and is at least 64-bits wide for
</span>   152    <span class="xdoc"> *          targets that support 64-bit integral types.
</span>   153    <span class="xdoc"> *
</span>   154    <span class="xdoc"> *      - `ULLong`
</span>   155    <span class="xdoc"> *          this unsigned long integer type is large enough to hold a `ULong`
</span>   156    <span class="xdoc"> *          and is defined as a 'unsigned long long' type on targets that
</span>   157    <span class="xdoc"> *          support this type; otherwise, it is simply a `ULong`.
</span>   158    <span class="xdoc"> *  <b>@p</b>
</span>   159    <span class="xdoc"> *
</span>   160    <span class="xdoc"> *  The `xdc/std.h` header also defines the following aliases for the base C
</span>   161    <span class="xdoc"> *  types.  These aliases exist so that C sources can consistently follow
</span>   162    <span class="xdoc"> *  a naming convention in which all type names are written in camel-case.
</span>   163    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   164    <span class="xdoc"> *      - `Char` and `UChar`
</span>   165    <span class="xdoc"> *          aliases for `char` and `unsigned char`, respectively
</span>   166    <span class="xdoc"> *      - `Short` and `UShort`
</span>   167    <span class="xdoc"> *          aliases for `short` and `unsigned short`, respectively
</span>   168    <span class="xdoc"> *      - `Int` and `UInt`
</span>   169    <span class="xdoc"> *          aliases for `int` and `unsigned int`, respectively
</span>   170    <span class="xdoc"> *      - `Long` and `ULong`
</span>   171    <span class="xdoc"> *          aliases for `long` and `unsigned long`, respectively
</span>   172    <span class="xdoc"> *      - `Double` and `LDouble`
</span>   173    <span class="xdoc"> *          aliases for `double` and `long double`, respectively
</span>   174    <span class="xdoc"> *      - `SizeT`
</span>   175    <span class="xdoc"> *          alias for `size_t`
</span>   176    <span class="xdoc"> *      - `VaList`
</span>   177    <span class="xdoc"> *          alias for `va_list`
</span>   178    <span class="xdoc"> *  <b>@p</b>
</span>   179    <span class="xdoc"> *  The types above are defined for all targets.  Some targets can support
</span>   180    <span class="xdoc"> *  the following additional types.  Since these types are not always
</span>   181    <span class="xdoc"> *  supported by a target, these types should only be used when no other
</span>   182    <span class="xdoc"> *  type sufficies.
</span>   183    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   184    <span class="xdoc"> *      - `Bits`n, where n = 8, 16, or 32
</span>   185    <span class="xdoc"> *          this unsigned integer type is precisely n-bits wide.  This type is
</span>   186    <span class="xdoc"> *          equivalent to the optional C99 type `uint`n`_t`; see ISO/IEC
</span>   187    <span class="xdoc"> *          9899:1999 Section 7.18.1.1.  This type is defined if and
</span>   188    <span class="xdoc"> *          only if the preprocessor macro `xdc__BITS`n`__` is defined.
</span>   189    <span class="xdoc"> *  <b>@p</b>
</span>   190    <span class="xdoc"> *  
</span>   191    <span class="xdoc"> *  <b>@a(64 Bit Types)</b>
</span>   192    <span class="xdoc"> *  Although the C99 standard requires support for 64-bit types, not all
</span>   193    <span class="xdoc"> *  compiler/device combinations can usefully support them.  As a result,
</span>   194    <span class="xdoc"> *  the 64-bit types described here may not be defined for all targets.  For
</span>   195    <span class="xdoc"> *  each type there is a corresponding pre-processor macro which is
</span>   196    <span class="xdoc"> *  defined if and only if the type is supported.
</span>   197    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   198    <span class="xdoc"> *      - `Int64`
</span>   199    <span class="xdoc"> *          signed integer type that is large enough to hold 64 bits; the
</span>   200    <span class="xdoc"> *          actual target type may by be wider than 64 bits.  This type is
</span>   201    <span class="xdoc"> *          equivalent to one of the C99 types `int_least64_t` or
</span>   202    <span class="xdoc"> *          `int_fast64_t`; see  Section 7.18.  This type is defined if and
</span>   203    <span class="xdoc"> *          only if the preprocessor macro `xdc__INT64__` is defined.
</span>   204    <span class="xdoc"> *      - `UInt64`
</span>   205    <span class="xdoc"> *          unsigned integer type that is large enough to hold n bits; the
</span>   206    <span class="xdoc"> *          actual target type may by be wider than 64 bits.  This type is
</span>   207    <span class="xdoc"> *          equivalent to one of the C99 types `uint_least64_t` or
</span>   208    <span class="xdoc"> *          `uint_fast64_t`; see ISO/IEC 9899:1999 Section 7.18.  This type
</span>   209    <span class="xdoc"> *          is defined if and only if the preprocessor macro
</span>   210    <span class="xdoc"> *          `xdc__INT64__` is defined.
</span>   211    <span class="xdoc"> *      - `Bits64`
</span>   212    <span class="xdoc"> *          unsigned integer type that is precisely 64 bits wide. If the target
</span>   213    <span class="xdoc"> *          does not support an exact 64-bit size, this type is not defined.
</span>   214    <span class="xdoc"> *          This type is equivalent to the corresponding C99 type
</span>   215    <span class="xdoc"> *          `uint64_t`; see ISO/IEC 9899:1999 Section 7.18.  This type is
</span>   216    <span class="xdoc"> *          defined if and only if the preprocessor macro `xdc__BITS64__` is
</span>   217    <span class="xdoc"> *          defined.
</span>   218    <span class="xdoc"> *  <b>@p</b>
</span>   219    <span class="xdoc"> *
</span>   220    <span class="xdoc"> *  <b>@a(Predefined Macros)</b>
</span>   221    <span class="xdoc"> *  In addition to the type definitions above, `xdc/std.h` also defines the
</span>   222    <span class="xdoc"> *  following commonly used constants
</span>   223    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   224    <span class="xdoc"> *      - `NULL`
</span>   225    <span class="xdoc"> *          defined as `0`
</span>   226    <span class="xdoc"> *      - `TRUE`
</span>   227    <span class="xdoc"> *          defined as `((Bool)1)`
</span>   228    <span class="xdoc"> *      - `FALSE`
</span>   229    <span class="xdoc"> *          defined as `((Bool)0)`
</span>   230    <span class="xdoc"> *  <b>@p</b>
</span>   231    <span class="xdoc"> *
</span>   232    <span class="xdoc"> *  Finally, `xdc/std.h` defines the following target-independent symbols
</span>   233    <span class="xdoc"> *  that have target-dependent values; these predefined macros enable
</span>   234    <span class="xdoc"> *  conditional compilation of source files based on target-specific
</span>   235    <span class="xdoc"> *  attributes.  
</span>   236    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   237    <span class="xdoc"> *      - {c_target_name}
</span>   238    <span class="xdoc"> *          this symbol (the target's fully qualified name with all '.'s
</span>   239    <span class="xdoc"> *          replaced with '_') is always defined and allows one to easily
</span>   240    <span class="xdoc"> *          include target-specific headers or define symbols with
</span>   241    <span class="xdoc"> *          target-specific values.
</span>   242    <span class="xdoc"> *
</span>   243    <span class="xdoc"> *      - `xdc_target__isaCompatible_`{isa_name}
</span>   244    <span class="xdoc"> *          for every ISA named in the array returned by this target's
</span>   245    <span class="xdoc"> *          `{<b>@link</b> xdc.bld.ITarget#getISAChain()}` method, a symbol of this
</span>   246    <span class="xdoc"> *          name is defined.  In addition to enabling one to create code
</span>   247    <span class="xdoc"> *          specific to a particular ISA, this allows one to create code that
</span>   248    <span class="xdoc"> *          depends on TI's C6x architecture without being dependent
</span>   249    <span class="xdoc"> *          on a particular member of the C6x family, for example.
</span>   250    <span class="xdoc"> *
</span>   251    <span class="xdoc"> *      - `xdc_target__isa_`{isa}
</span>   252    <span class="xdoc"> *          this symbol is always defined  and {isa} is the
</span>   253    <span class="xdoc"> *          target's `isa` (see `{<b>@link</b> xdc.bld.ITarget#isa}`).
</span>   254    <span class="xdoc"> *
</span>   255    <span class="xdoc"> *      - `xdc_target__`{little,big}`Endian`
</span>   256    <span class="xdoc"> *          if this target's `{<b>@link</b> xdc.bld.ITarget#model}.endian` property is
</span>   257    <span class="xdoc"> *          specified, this symbol is defined and {little,big} is replaced
</span>   258    <span class="xdoc"> *          by `model.endian`.
</span>   259    <span class="xdoc"> *
</span>   260    <span class="xdoc"> *      - `xdc_target__`{code_model_name}`Code`
</span>   261    <span class="xdoc"> *          if this target's `{<b>@link</b> xdc.bld.ITarget#model}.codeModel` is
</span>   262    <span class="xdoc"> *          specified, this symbol is defined and {code_model_name} is
</span>   263    <span class="xdoc"> *          replaced by `model.codeModel`.
</span>   264    <span class="xdoc"> *
</span>   265    <span class="xdoc"> *      - `xdc_target__`{data_model_name}`Data`
</span>   266    <span class="xdoc"> *          if this target's `{<b>@link</b> xdc.bld.ITarget#model}.dataModel` is
</span>   267    <span class="xdoc"> *          specified, this symbol is defined and {data_model_name} is
</span>   268    <span class="xdoc"> *          replaced by `model.dataModel`.
</span>   269    <span class="xdoc"> *
</span>   270    <span class="xdoc"> *      - `xdc_target__os_`{os_name}
</span>   271    <span class="xdoc"> *          this symbol is always defined  and {os_name} is the
</span>   272    <span class="xdoc"> *          target's os name (see `{<b>@link</b> xdc.bld.ITarget#os}`).
</span>   273    <span class="xdoc"> *
</span>   274    <span class="xdoc"> *      - `xdc_target__sizeof_`{type_name}
</span>   275    <span class="xdoc"> *          this symbol is defined for each type name supported in the target's
</span>   276    <span class="xdoc"> *          `{<b>@link</b> xdc.bld.ITarget#stdTypes}` structure, {type_name} is the
</span>   277    <span class="xdoc"> *          name of one of the standard types supported above, and the 
</span>   278    <span class="xdoc"> *          value is `sizeof(type_name)`.
</span>   279    <span class="xdoc"> *
</span>   280    <span class="xdoc"> *      - `xdc_target__alignof_`{type_name}
</span>   281    <span class="xdoc"> *          this symbol is defined for each type name supported in the target's
</span>   282    <span class="xdoc"> *          `{<b>@link</b> xdc.bld.ITarget#stdTypes}` structure, {type_name} is the
</span>   283    <span class="xdoc"> *          name of one of the standard types supported above, and the
</span>   284    <span class="xdoc"> *          value is the alignment required by the compiler for {type_name}.
</span>   285    <span class="xdoc"> *
</span>   286    <span class="xdoc"> *      - `xdc_target__bitsPerChar`
</span>   287    <span class="xdoc"> *          this symbol is always defined and specifies the number of bits 
</span>   288    <span class="xdoc"> *          in the target's `char`.  This value combined with the
</span>   289    <span class="xdoc"> *          `xdc_target__sizeof_` values allows C code to determine the
</span>   290    <span class="xdoc"> *          precise number of bits in any of the standard types.
</span>   291    <span class="xdoc"> *  <b>@p</b>
</span>   292    <span class="xdoc"> *
</span>   293    <span class="xdoc"> *  <b>@a(See)</b>
</span>   294    <span class="xdoc"> *  {<b>@link</b> http://www.open-std.org/jtc1/sc22/wg14/www/standards ISO-IEC JTC1-SC22-WG14 - C Approved standards}
</span>   295    <span class="xdoc"> *
</span>   296    <span class="xdoc"> *  <b>@a(Throws)</b>
</span>   297    <span class="xdoc"> *  `XDCException` exceptions are thrown for fatal errors. The following
</span>   298    <span class="xdoc"> *  error codes are reported in the exception message:
</span>   299    <span class="xdoc"> *  <b>@p(dlist)</b>
</span>   300    <span class="xdoc"> *      - `xdc.PACKAGE_NOT_FOUND`
</span>   301    <span class="xdoc"> *           This error is reported whenever a specified package is not found
</span>   302    <span class="xdoc"> *           This may happen for the following reasons:
</span>   303    <span class="xdoc"> *      <b>@p(blist)</b>
</span>   304    <span class="xdoc"> *            -  Ensure that the package in question is contained in one of
</span>   305    <span class="xdoc"> *               the repositories named in the package path.  
</span>   306    <span class="xdoc"> *            -  The package has not been built by the `xdc` tool even though
</span>   307    <span class="xdoc"> *               the physical package directory may be present along the
</span>   308    <span class="xdoc"> *               package path
</span>   309    <span class="xdoc"> *   <b>@p(dlist)</b>
</span>   310    <span class="xdoc"> *     - `xdc.FILE_NOT_FOUND`
</span>   311    <span class="xdoc"> *            This error is reported when a specified file is not found. 
</span>   312    <span class="xdoc"> *            Ensure that any directory name prefix in the name is a package
</span>   313    <span class="xdoc"> *            directory contained in one of the repositories named in the
</span>   314    <span class="xdoc"> *            package path.  For example, if "ti/targets/linkcmd.xdt" can't
</span>   315    <span class="xdoc"> *            be found, make sure the directory `ti/targets/` is contained in
</span>   316    <span class="xdoc"> *            at least one repository named in the package path.
</span>   317    <span class="xdoc"> *      - `xdc.MODULE_NOT_FOUND`
</span>   318    <span class="xdoc"> *            This error is reported when a specified module can't be
</span>   319    <span class="xdoc"> *            found. Ensure that the package containing the module in
</span>   320    <span class="xdoc"> *            question is contained in at least one repository named in
</span>   321    <span class="xdoc"> *            the package path.
</span>   322    <span class="xdoc"> *            Also ensure that the module name is qualified with the
</span>   323    <span class="xdoc"> *            package name. For example, to refer to the module `Engine`
</span>   324    <span class="xdoc"> *            in the package `ti.sdo.ce`, the module name should be
</span>   325    <span class="xdoc"> *            specified as `ti.sdo.ce.Engine`.
</span>   326    <span class="xdoc"> *      - `xdc.TOOL_USAGE_ERROR`
</span>   327    <span class="xdoc"> *            This error may happen when the `xs` tool is not passed the
</span>   328    <span class="xdoc"> *            expected command line arguments. 
</span>   329    <span class="xdoc"> *      - `xdc.MODULE_UNDEFINED_MAIN_FUNCTION`
</span>   330    <span class="xdoc"> *            This error is reported when the `xs` tool is passed a module
</span>   331    <span class="xdoc"> *            that does not define a `main` function. Ensure that the
</span>   332    <span class="xdoc"> *            meta-domain implementation of the module has a `main` function.
</span>   333    <span class="xdoc"> *      - `xdc.SPEC_FILE_ERROR`
</span>   334    <span class="xdoc"> *            This error is reported when there is a parsing error in a
</span>   335    <span class="xdoc"> *            specification file. Check the spec. file for syntax errors.
</span>   336    <span class="xdoc"> *      - `xdc.DEPRECATED_FUNCTION`
</span>   337    <span class="xdoc"> *            This error is reported whenever a deprecated function is called.
</span>   338    <span class="xdoc"> *      - `xdc.STATIC_INSTANCE`
</span>   339    <span class="xdoc"> *            This error is reported when a function create() is called at the
</span>   340    <span class="xdoc"> *            configuration time for a module that does not implement the
</span>   341    <span class="xdoc"> *            function instance$static$init and therefore does not support
</span>   342    <span class="xdoc"> *            static instances. 
</span>   343    <span class="xdoc"> */</span>
   344    <span class=key>package</span> xdc [1, 1, 1] {
   345        <span class="comment">/* base interface for all XDC packages */</span>
   346        <span class=key>interface</span> IPackage;
   347        <span class=key>module</span> Warnings;
   348    }
   349    <span class="comment">/*
</span>   350    <span class="comment"> *  @(#) xdc; 1, 1, 1,0; 12-9-2015 17:34:58; /db/ztree/library/trees/xdc/xdc-B06/src/packages/
</span>   351    <span class="comment"> */</span>
   352    
</pre>
</body></html>
